#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
combine-text â€” append right-hand text after piped stdin (stdin -> stdout filter)

USAGE
  <left-pipeline> | combine-text [OPTIONS] [TEXT...]
  combine-text [OPTIONS] [TEXT...]         # also works without a pipe (reads stdin until EOF)

DESCRIPTION
  - Streams stdin to stdout unchanged.
  - Then appends TEXT (arguments joined by single spaces) to stdout.
  - By default, inserts a blank line between stdin output and TEXT (when both exist).

OPTIONS
  -b, --blank     Ensure TEXT starts after a blank line (default).
                  (If stdin doesn't end with '\n', it will add what's needed.)
  -1, --newline   Ensure TEXT starts on a new line (no extra blank line).
  -0, --none      Do not insert a separator.
  -h, --help      Show this help.
  --              End of options (useful if TEXT begins with '-')

EXAMPLES
  ls -la | combine-text "---- end ----"
  git status | combine-text -1 "Next:" "run tests"
  printf "no-newline" | combine-text "appended"

NOTES
  - TEXT is treated as literal text; this program does NOT execute commands you pass as arguments.
  - To include spaces/newlines reliably, quote your TEXT.
EOF
}

sep="blank"

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help) usage; exit 0 ;;
    -b|--blank) sep="blank"; shift ;;
    -1|--newline) sep="newline"; shift ;;
    -0|--none) sep="none"; shift ;;
    --) shift; break ;;
    -*) printf 'combine-text: unknown option: %s\n\n' "$1" >&2; usage >&2; exit 2 ;;
    *) break ;;
  esac
done

# We want:
# 1) Stream stdin to stdout unchanged
# 2) Detect whether stdin ended with '\n' (without consuming stdin twice)
#
# Trick:
# - Duplicate stdout to fd 3
# - tee stdin to:
#    a) cat -> fd 3 (so input streams out immediately)
#    b) tail -c 1 -> od (so we can detect last byte as a number)
exec 3>&1
last_byte_code="$(
  tee >(cat >&3) \
  | tail -c 1 \
  | od -An -t u1 \
  | tr -d ' \t\n'
)"

saw_stdin=0
ended_with_nl=0
if [[ -n "$last_byte_code" ]]; then
  saw_stdin=1
  [[ "$last_byte_code" == "10" ]] && ended_with_nl=1
fi

# If no TEXT was provided, we're done after streaming stdin.
if (( $# == 0 )); then
  exit 0
fi

# Insert separator only if stdin had something.
if (( saw_stdin == 1 )); then
  case "$sep" in
    blank)
      # Want TEXT to start after a blank line.
      # If stdin already ended with '\n' -> add 1 more '\n' (creates one blank line).
      # If not -> add "\n\n" (terminates line + blank line).
      if (( ended_with_nl == 1 )); then
        printf '\n'
      else
        printf '\n\n'
      fi
      ;;
    newline)
      # Ensure TEXT starts on a new line, but no extra blank line.
      if (( ended_with_nl == 0 )); then
        printf '\n'
      fi
      ;;
    none)
      ;;
  esac
fi

# Print TEXT args joined by single spaces, then newline.
printf '%s' "$1"
shift
for a in "$@"; do
  printf ' %s' "$a"
done
printf '\n'
