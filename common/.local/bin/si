#!/usr/bin/env bash
# si â€” Create/update Zoekt index under <root>/.zoekt and (optionally) index nested repos.
# Also manages git hooks to auto-refresh, and clears sz memoized caches for consistency.

set -euo pipefail

usage() {
  cat <<'USAGE'
Usage:
  si [PATH]                         Index PATH (or git root or $PWD) into <root>/.zoekt
  si --nested [MODE] [PATH]         Also index nested repos; MODE: off | smart | deep (default: smart)
  si --install-hooks [PATH]         Install post-merge & post-checkout hooks for PATH (repo)
  si --install-global-hooks         Install hooks into ~/.git-templates/hooks (set core.hooksPath)

Environment:
  SI_NESTED_SCAN        default nested mode if --nested omitted: off | smart | deep (default: smart)
  SZ_NESTED_MAX_DEPTH   max depth for 'deep' scan (default: 4)
  SI_IGNORE_DIRS        extra dirs to ignore for plain-directory indexing (comma-separated)

Details:
- Git repos use:    zoekt-git-index -index <root>/.zoekt <repo>
- Non-git dirs use: zoekt-index    -index <root>/.zoekt -ignore_dirs ".git,.hg,.svn,.zoekt[,<SI_IGNORE_DIRS>]" <root>
- Hooks run 'si <root>' after pulls/branch switches to keep the index fresh.
USAGE
}

abs_path() { (cd "$1" >/dev/null 2>&1 && pwd -P) || return 1; }

sha1_of() {
  if command -v sha1sum >/dev/null 2>&1; then
    printf '%s' "$1" | sha1sum | awk '{print $1}'
  else
    printf '%s' "$1" | shasum | awk '{print $1}'
  fi
}

clear_sz_cache_for_root() {
  local root="$1"
  local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/sz"
  local key
  mkdir -p "$cache_dir"
  key="$(sha1_of "$(abs_path "$root")")"
  rm -f "$cache_dir/${key}.changed" "$cache_dir/${key}.deleted" "$cache_dir/${key}.nested" 2>/dev/null || true
}

write_hook() {
  local hook_path="$1" si_bin="$2"
  mkdir -p "$(dirname "$hook_path")"
  cat > "$hook_path" <<EOFHOOK
#!/usr/bin/env bash
set -euo pipefail
SI_BIN="$si_bin"
if [[ ! -x "$SI_BIN" ]]; then
  SI_BIN="si"  # fallback to PATH if absolute path missing
fi
root="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
# Quiet re-index; ignore errors so hooks never block merges/checkouts.
"$SI_BIN" "$root" >/dev/null 2>&1 || true
EOFHOOK
  chmod +x "$hook_path"
}

install_repo_hooks() {
  local repo="$1"
  if not_git=$(git -C "$repo" rev-parse --is-inside-work-tree >/dev/null 2>&1; echo $?); then
    if [[ "$not_git" -ne 0 ]]; then
      echo "Not a git repo: $repo" >&2
      exit 1
    fi
  fi
  local hooks_dir="$repo/.git/hooks"
  local si_bin
  si_bin="$(command -v si || true)"
  [[ -z "$si_bin" ]] && si_bin="si"
  write_hook "$hooks_dir/post-merge" "$si_bin"
  write_hook "$hooks_dir/post-checkout" "$si_bin"
  echo "Installed hooks: $hooks_dir/post-merge, $hooks_dir/post-checkout"
}

install_global_hooks() {
  local tmpl="$HOME/.git-templates/hooks"
  mkdir -p "$tmpl"
  local si_bin
  si_bin="$(command -v si || true)"
  [[ -z "$si_bin" ]] && si_bin="si"
  write_hook "$tmpl/post-merge" "$si_bin"
  write_hook "$tmpl/post-checkout" "$si_bin"
  echo "Installed global hooks to: $tmpl"
  echo "If not already set, run:"
  echo "  git config --global core.hooksPath \"$HOME/.git-templates/hooks\""
}

discover_nested() {
  local root="$1" mode="$2" depth="${SZ_NESTED_MAX_DEPTH:-4}"
  local -a repos=()
  if [[ "$mode" != "off" ]]; then
    for cand in \
      "third_party/skia" "third_party/v8" "v8" "third_party/angle" \
      "third_party/pdfium" "third_party/swiftshader" "third_party/dawn" \
      "third_party/blink" "third_party/perfetto" "third_party/catapult" \
      "third_party/spirv-tools" "third_party/spirv-headers" "third_party/icu"; do
      [[ -d "$root/$cand/.git" ]] && repos+=("$root/$cand")
    done
    if [[ "$mode" == "deep" ]]; then
      while IFS= read -r g; do
        [[ "$g" == "$root/.git" ]] && continue
        repos+=("${g%/.git}")
      done < <(find "$root" -mindepth 2 -maxdepth "$depth" -type d -name .git \
               -not -path "$root/.git" \
               -not -path "$root/out/*" 2>/dev/null)
    fi
  fi
  if ((${#repos[@]})); then
    printf '%s\n' "${repos[@]}" | awk '!seen[$0]++'
  fi
}

index_repo_git() {
  local where="$1" idx="$2"
  echo "Indexing (git) $where -> $idx"
  zoekt-git-index -index "$idx" "$where"
}

index_repo_dir() {
  local where="$1" idx="$2"
  local ignores=".git,.hg,.svn,.zoekt"
  [[ -n "${SI_IGNORE_DIRS:-}" ]] && ignores="$ignores,${SI_IGNORE_DIRS}"
  echo "Indexing (dir) $where -> $idx (ignore_dirs: $ignores)"
  zoekt-index -index "$idx" -ignore_dirs "$ignores" "$where"
}

# ---- flag parsing
if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then usage; exit 0; fi

case "${1:-}" in
  --install-hooks)
    shift
    target="${1:-}"
    if [[ -z "$target" ]]; then
      if git_root=$(git rev-parse --show-toplevel 2>/dev/null); then
        target="$git_root"
      else
        target="$PWD"
      fi
    fi
    target="$(abs_path "$target")"
    install_repo_hooks "$target"
    exit 0
    ;;
  --install-global-hooks)
    install_global_hooks
    exit 0
    ;;
  --nested)
    shift
    nested_mode="${1:-${SI_NESTED_SCAN:-smart}}"
    [[ "$nested_mode" != "off" && "$nested_mode" != "smart" && "$nested_mode" != "deep" ]] && {
      echo "Invalid --nested mode: $nested_mode" >&2; exit 1; }
    shift || true
    ;;
  *)
    nested_mode="${SI_NESTED_SCAN:-smart}"
    ;;
esac

# Resolve target dir
if [[ -n "${1:-}" ]]; then
  target="$(abs_path "$1")"
elif git_root=$(git rev-parse --show-toplevel 2>/dev/null); then
  target="$(abs_path "$git_root")"
else
  target="$(abs_path "$PWD")"
fi

index_dir="${target}/.zoekt"
mkdir -p "$index_dir"

# Index target and optional nested repos
if git -C "$target" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  index_repo_git "$target" "$index_dir"
else
  index_repo_dir "$target" "$index_dir"
fi

# Nested indexing (Chromium-friendly)
while IFS= read -r nr; do
  git -C "$nr" rev-parse --is-inside-work-tree >/dev/null 2>&1 || continue
  index_repo_git "$nr" "$index_dir"
done < <(discover_nested "$target" "$nested_mode")

echo "Done. Shards in: $index_dir"

# Clear sz memoized caches for this root so overlay is consistent immediately
clear_sz_cache_for_root "$target"

